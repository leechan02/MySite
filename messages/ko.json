{
  "title": "이의찬",
  "description": "이의찬의 개인 웹사이트에 오신 것을 환영합니다!",
  "header": {
    "home": "홈",
    "projects": "프로젝트",
    "info": "정보"
  },
  "resume": {
    "resume": "/resume/Resume(ko).pdf"
  },
  "work": {
    "mainTitle": "세상이 가진 불편한 문제들을 해결하고 싶습니다.",
    "subTitle": "만드는 거 좋아함.",
    "bookmoeum": {
      "title": "책모음",
      "date": "서울 2024년 8월",
      "description": "책 검색 웹서비스."
    },
    "mysite": {
      "title": "마이사이트",
      "date": "서울 2024년 9월",
      "description": "포트폴리오 웹사이트."
    },
    "webserv": {
      "title": "웹서브",
      "date": "42서울 2023년 8월-2023년 11월",
      "description": "c++98로 만든 웹서버."
    },
    "transcendence": {
      "title": "트랜센던스",
      "date": "42서울 2023년 12월-2024년 3월",
      "description": "SPA 핑퐁게임 웹사이트."
    }
  },
  "info": {
    "mainTitle": "안녕하세요, 이의찬입니다.",
    "subTitle": "문제를 정의하고 해결해 세상을 조금 더 편리하게 만드는 것을 좋아합니다.",
    "about": {
      "leftFirstTitle": "컴퓨터공학을 선택한 배경",
      "leftFirstContent": [
        "처음부터 개발에 관심이 있던 건 아니었습니다. 2년 전만 해도 코딩의 코자도 모르던 학생이었지만, 세상에 관심이 많아지기 시작하면서 불편한 점들이 많이 존재한다는 사실을 발견하게 됩니다.",
        "그 과정에서 문제 정의 능력의 중요성을 알게 되었고, 그 문제를 해결하기 위한 기술에 관심을 갖게 됩니다.",
        "그 결과 단순히 강의 위주로만 학습하는 것이 아닌 프로젝트 위주의 능동적인 학습을 통해 운영체제, 자료구조, 알고리즘, 네트워크 등등 컴퓨터공학의 기본 개념들을 배울 수 있는 42서울이라는 학교를 발견하였고, 2년간의 학습을 마친 후 현재는 개발자를 지망하고 있습니다."
      ],
      "leftSecondTitle": "코딩 스타일",
      "leftSecondContent": [
        "아름다운 것을 좋아합니다. 그렇기 때문에 코드를 작성할 때 처음 보는 사람도 이해할 수 있는지, 구조가 복잡하지는 않은지 고민하며, 최적화를 위해 늘 코드 재사용성을 생각합니다.",
        "혼자보다는 여러명이 더 낫다고 생각하기 때문에 개발자에게 커뮤니케이션 능력은 필수라고 생각합니다. 노베이스에서 시작했기 때문에 누구나 알아듣기 쉽도록 설명하는 것을 좋아하고 잘합니다.",
        "AI를 활용해 시간을 아낍니다. 코드의 퀄리티를 높일 수 있는 방법이나 검색 대신 사용하는 편이고, 이상하다 싶으면 구글링과 공식문서를 보고 코드를 보안해나갑니다."
      ],
      "rightFirstTitle": "궁금한 것이 많습니다",
      "rightFirstContent": [
        "저는 궁금한 게 많고, 배우고 싶은 것도 많습니다. 살아가다 보면 아는 것보다 모르는 것투성이라는 사실만 알게 됩니다. 하지만 이 때문에 저는 항상 틀릴 수 있음을 인지하고 언제나 더 성장하려고 노력합니다.",
        "세상에 어려운 것은 있지만 불가능한 것은 없다고 생각합니다. 2년 전 완전 새로운 분야에 도전했기 때문에, 남들보다 더 열심히 할 수밖에 없었습니다. ",
        "문제가 생길 때마다 어떻게든 해결해 나갔고, 컴퓨터공학 기초 지식을 쌓음과 동시에 300번이 넘는 코드 리뷰와 한 프로젝트에서 10,000줄이 넘는 코드를 작성하는 등의 경험을 쌓아나갔습니다.",
        "그 결과 새로운 지식과 기술을 습득하고 문제를 마주하는 데에 두려움이 없어졌습니다. 기술적인 예로는 완전히 새로 배우는 프레임워크인 Next.js도 3주만에 웹사이트를 만들어 배포한 경험도 있습니다."
      ],
      "rightSecondTitle": "여가 시간에는,",
      "rightSecondContent": [
        "아는 만큼 보게 되고, 보는 만큼 꿈꿀 수 있다고 생각합니다. 그렇기 때문에 배우는 것, 도전하는 것, 기록하는 것을 좋아합니다.",
        "알고, 보고 싶기 때문에 책을 읽습니다. 도전하는 것을 좋아해서 일단 해봅니다. 최근에는 히말라야에 올라갔다 왔습니다.",
        "배운 것은 기록하고 말해야 본인 것이 된다고 생각합니다. 끄적이는 성장 일기 같이 유튜브도 조그맣게 운영하고 있습니다."
      ]
    },
    "education": {
      "first": "42서울",
      "firstLocation": "한국, 서울",
      "firstDate": "2022년 7월 - 2024년 7월",
      "firstContent": "다양한 토이 프로젝트를 통한 컴퓨터공학 지식 학습",
      "second": "한국방송통신대학교",
      "secondLocation": "한국, 서울",
      "secondDate": "2023년 9월 - 현재",
      "secondContent": "2028년 졸업 예정, 컴퓨터공학 학사"
    },
    "etc": {
      "first": "오픽 AL",
      "second": "정보처리기능사"
    },
    "skills": {
      "title": "SKILLS",
      "language": {
        "title": "언어",
        "skills": "C/C++, JavaScript, TypeScript, HTML, CSS, English",
        "details": [
          {
            "skill": "C/C++ ⭐️⭐️",
            "description": "멀티 프로세스, 멀티 스레드, 객체지향 프로그래밍, 메모리 관리를 고려한 여러 토이 프로젝트 구현본 경험이 있습니다."
          },
          {
            "skill": "JavaScript ️⭐⭐️️",
            "description": "const, let과 var의 차이를 알고 있으며, Vanilla JavaScript만으로 react 처럼 component 모듈화를 활용한 SPA 사이트를 만든 경험이 있습니다."
          },
          {
            "skill": "TypeScript ⭐️",
            "description": "React 사용하면서 interface를 활용한 타입을 설정하여 사용할 줄 압니다."
          },
          {
            "skill": "HTML ⭐⭐️️",
            "description": "html로 페이지 만들기 가능합니다."
          },
          {
            "skill": "CSS ⭐⭐️️",
            "description": "flex 개념에 대해 이해하고 있으며, CSS로 만들고 싶은 디자인을 구현할 수 있습니다."
          },
          {
            "skill": "English ⭐️⭐️⭐️",
            "description": "오픽 AL, 원어민과 무리없이 의사소통 가능합니다. 사용하던 기술에 궁금한 것이 있을 때 영어기술문서를 읽는데에 문제없습니다."
          }
        ]
      },
      "frontend": {
        "title": "프론트엔드",
        "skills": "React, Next.js, React Query, Redux, TailwindCSS, Framer Motion, i18n",
        "details": [
          {
            "skill": "React ⭐️⭐️",
            "description": "React를 참고해 JavaScript만으로 컴포넌트 모듈화를 구현한 경험으로 React 컴포넌트 구조에 대해 이해하고 있으며 React-dom을 사용한 route 및 컴포넌트를 활용할 수 있습니다."
          },
          {
            "skill": "Next.js ⭐️⭐️",
            "description": "SSR과 CSR의 차이에 대해 알고 있으며, 동적라우팅 및 middleware를 사용한 라우팅을 활용해 서비스를 배포해본 경험이 있습니다."
          },
          {
            "skill": "React Query ⭐️",
            "description": "query 사용한 api 캐시 관리 및 무한 스크롤 구현 경험이 있습니다."
          },
          {
            "skill": "Redux ⭐️",
            "description": "Redux와 비슷한 pub/sub 패턴을 javascript로 구현해 본 경험으로 구조에 대해 이해하고 있으며 Redux를 활용한 기본적인 상태관리를 할 수 있습니다."
          },
          {
            "skill": "TailwindCSS ⭐️⭐️",
            "description": "웬만한 디자인은 tailwindcss로 구현 가능하며 개발 디자인 커스텀이 가능합니다."
          },
          {
            "skill": "Framer Motion ⭐️",
            "description": "간단한 애니메이션 효과 구현 가능합니다."
          },
          {
            "skill": "i18n ⭐️⭐️",
            "description": "i18n 라이브러리를 활용한 한영전환 기능을 구현해본 경험이 있습니다."
          }
        ]
      },
      "tools": {
        "title": "기타",
        "skills": "Git/GitHub, Figma, Slack, Notion, Visual Studio Code, Docker",
        "details": [
          {
            "skill": "Git/GitHub ⭐️⭐",
            "description": "Git Issue 관리 및 브랜치 전략 적용, 팀 협업이 가능합니다."
          },
          {
            "skill": "Figma ⭐️⭐️⭐️",
            "description": "디자인 시스템 구축 및 프로토타입 제작 가능합니다."
          },
          {
            "skill": "Slack ⭐️⭐️⭐️",
            "description": "상시대기, 팀원과 원활한 소통가능합니다."
          },
          {
            "skill": "Notion ⭐️⭐️⭐️",
            "description": "웬만한 정보는 노션으로 정리, 팀 프로젝트 당시 항상 팀스페이스 노션 정리 담당이었습니다."
          },
          {
            "skill": "Visual Studio Code ⭐️⭐️️",
            "description": "비쥬얼스튜디오에서 vim 플러그인 사용하는 혼종유저입니다."
          },
          {
            "skill": "Docker ⭐️",
            "description": "도커의 기본 개념을 알고 있고 도커 이미지 빌드 및 세팅 가능합니다."
          }
        ]
      }
    }
  },
  "webserv": {
    "content": {
      "title": "웹서브",
      "date": "42서울 2023년 8월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "구조 설계, Config 파싱, HTTP 파싱, 디버깅 로그 작성, 코드 리펙토링, 동작 확인 페이지 구현",
      "teamTitle": "팀",
      "team": ["허진호", "안현준", "임윤선"],
      "timelineTitle": "타임라인",
      "timeline": "4달, 2023년 8월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "C++98, Makefile, HTML, CSS, Object Oriented Programming, Non-block I/O, I/O Multiplexing (kqueue), HTTP/1.1",
      "overviewTitle": "개요",
      "overview": [
        "웹서브는 42서울 프로젝트 중 하나로 C++98로 구현된 HTTP/1.1 호환 웹 서버를 구현하는 프로젝트입니다. 이 프로젝트는 저수준 네트워크 프로그래밍에 대한 숙련도와 HTTP 프로토콜에 대한 이해, 그리고 논블로킹 I/O 작업과 효율적인 요청 처리의 구현을 요구합니다.",
        "주요 기능으로는 kqeue() (또는 이와 동등한 기능)를 사용한 I/O 멀티플렉싱이 있어, 서버가 절대 블로킹되거나 무한정 멈추지 않도록 보장합니다. 또한 GET, POST, DELETE 등 여러 HTTP 메서드를 지원하면서 정적 웹사이트를 제공 해야합니다.",
        "이러한 고급 개념들을 구현함으로써, 웹서브는 웹 서버 아키텍처를 이해하기 위한 실용적인 학습 도구로서의 역할뿐만 아니라, 고성능 네트워크 애플리케이션을 만드는 데 있어 개체지향 프로그래밍 언어인 C++의 강력함과 유연성을 보여줍니다."
      ]
    },
    "highlights": {
      "title": "하이라이트",
      "highlights": "C++98로 구현된 HTTP/1.1 호환 웹서버입니다."
    },
    "problem": {
      "title": "THE PROBLEM",
      "subTitle": "Nignx를 참고해서 만들면 되지 않을까?",
      "first": "Nignx 구조",
      "firstContent": [
        "처음에는 Nginx 구조를 참조해 마스터 프로세스가 워커 프로세스를 생성하고 워커 프로세스에서는 각 쓰레드에 따라서 신호를 등록하고 응답을 보내는 멀티 프로세스 멀티 스레드 구조를 생각하고 코드를 작성했습니다.",
        "하지만 구조를 거의 다 작성했을 때 쯤, 프로세스는 하나만 사용해야 한다는 사용자 요구 사항을 발견해 결국 설정파일 파싱만 Nginx를 참고해서 만드는 것에 만족해야 했습니다."
      ]
    },
    "architecture": {
      "title": "ARCHITECTURE",
      "subTitle": "웹서버의 구조는 어떻게 되어야 하는가?",
      "first": "하나의 프로세스",
      "firstContent": [
        "하나의 프로세스에서 kqueue를 통해 이벤트를 관리하고 핸들링합니다.",
        "설정파일을 토대로 포트를 확인하고 연결합니다. 이벤트는 kqueue에서 관리되고 상속된 클래스에 따라 Read, Write, CGI 등으로 나누어져서 처리가 됩니다.",
        "응답이 들어오면 HTTP 형식에 맞춰서 파싱이 되며 그에 맞는 요청을 처리하고 응답을 내보냅니다."
      ]
    },
    "config": {
      "title": "CONFIG",
      "subTitle": "Nignx와 유사한 설정 파일 파싱 구조.",
      "first": "Config Tree",
      "firstContent": [
        "설정 파일은 {}, ;를 기준으로 블럭 형식으로 되어있고, 감싸고 있는 괄호를 부모라고 한다면 자식요소는 부모 요소의 설정을 반영합니다.",
        "그렇기 때문에 {}와 ;를 기준으로 트리를 구성한다면 location 블럭이 수 없이 들어가도 부모 요소의 모든 설정을 다 반영할 수 있습니다."
      ],
      "firstCodeEx": ["트리와 Map은 Common 클래스에서 전역으로 관리됩니다."],
      "secondCodeEx": [
        "WebServer가 생성되면 생성됨과 동시에 생성자에서 config 파일을 넘겨줘서 파싱을 완료합니다."
      ],
      "thirdCodeEx": [
        "트리는 Node로 관리하고, http, server, location 블럭 레벨로 나누어져 관리됩니다. 각 노드는 각각 레벨에서 보유해야 할 토큰과 부모 요소 그리고 자식 노드들 가지고 있습니다."
      ],
      "second": "Config Map",
      "secondContent": [
        "토큰을 기준으로 트리가 생성되었다면, location을 기준으로 Map을 생성해줍니다. 트리에서 location이 어디에 위치해있는지 기억하기만 한다면 들어온 location을 찾으려고 트리를 다 검색할 필요없이 location 위치에서 부모요소를 타고 올라가면서 설정들을 확인만 하면 되기 때문입니다."
      ],
      "fourthCodeEx": [
        "port, server_name, location을 기준으로 Map을 생성합니다. MultiMap을 사용함으로서. 트리를 다 순회하면서 location 노드를 찾을 필요없기때문에 접근시간을 O(N)에서 O(logN)으로 줄였습니다.",
        "std::unordered_map(hashmap)을 사용하면 O(1)로 더 줄일 수 있었지만, c++98에서는 해당 STL을 제공하지 않아 사용할 수 없었습니다."
      ],
      "fifthCodeEx": [
        "Nginx에서는 PCRE 라이브러리를 지원해 검사하지만, 이 프로젝트에서는 '~' '*' '$' 문법만 지원하도록 구현되어있습니다."
      ],
      "sixthCodeEx": [
        "Map에서 location 블럭을 검색할 때 PCRE 검사를 부분적('~', '*', '$')으로 지원합니다."
      ],
      "seventhCodeEx": [
        "port와 host uri를 알기만하면 location node를 가져올 수 있고, 그 node를 기준으로 설정된 세팅값이 뭔지 FindValue를 통해 가져올 수 있습니다."
      ]
    },
    "http": {
      "title": "REQUEST&&RESPONSE",
      "subTitle": "서버에서 요청을 받고 응답을 하는 과정.",
      "first": "요청 수신",
      "firstContent": [
        "서버는 recv() 함수를 통해 클라이언트로부터 데이터를 수신하고, 이 데이터를 각각의 Connection 객체가 소유한 Http 객체로 전달하여 HTTP 요청 파싱을 시작합니다."
      ],
      "second": "응답",
      "secondContent": [
        "파싱된 요청이 HTTP 요청인 경우, 서버는 Router를 통해 HTTP 메서드(GET, POST, DELETE)에 맞는 핸들러를 호출합니다.",
        "각 메서드는 HTTP/1.1 프로토콜을 준수하여 규칙에 맞는 적합한 비즈니스 로직을 처리한 후 적절한 Response 메시지를 생성하여 클라이언트에 응답합니다."
      ],
      "third": "CGI 요청 처리",
      "thirdContent": [
        "CGI 요청인 경우, 서버의 메인 프로세스는 fork() 시스템 호출을 통해 자식 프로세스를 생성하고, 자식 프로세스는 execve()를 통해 CGI 스크립트를 실행합니다.",
        "위와같은 방식은 CGI 요청이 메인 프로세스의 성능에 영향을 주지 않도록 설계된 비동기 처리 방식입니다."
      ]
    },
    "parsing": {
      "title": "HTTP PARSER",
      "subTitle": "HTTP 요청을 파싱하는 방법.",
      "first": "HTTP 요청 처리",
      "firstContent": [
        "파싱 과정에서 요청의 유효성을 검증한 후, 유효한 요청인 경우에만 다음 단계로 넘어갑니다. 요청은 한 글자씩 세밀하게 분석되어 상태에 따라 처리됩니다.",
        "Response 메시지 또한 HTTP/1.1 프로토콜을 준수하여 상태코드,헤더,본문 등과 같은 내용들로 메시지를 구성하여 생성합니다."
      ],
      "firstCodeEx": [
        "요청이 한번에 다 들어오는 것이 아닌 잘려서 들어오거나 겹쳐서 들어오기 때문에 while을 돌면서 mBuffer에 있는 값을 파싱해줍니다."
      ],
      "secondCodeEx": [
        "state를 통해 현재 파싱하고 있는 값이 무엇인지 검사합니다."
      ],
      "thirdCodeEx": ["HTTP/1.1 규격에 맞춰서 들어온 요청 문법을 검사합니다. "],
      "fourthCodeEx": ["실행한 결과를 응답 규격에 맞춰서 작성합니다."]
    },
    "test": {
      "title": "TEST",
      "subTitle": "만든 웹서버가 작동을 잘 하는가?",
      "first": "테스트 방법",
      "firstContent": [
        "여러 location으로 redirect가 잘 되는지, 수천번의 요청에도 서버가 종료되지 않고 잘 작동을 하는지, 크기가 max를 넘어간 요청을 보내도 종료되지는 않는지, 클라이언트가 접속을 끊었을때 소켓이 잘 닫히는지, 올바르지 않은 요청을 보냈을 때 오류를 잘 내보내는지 등을 확인합니다."
      ]
    }
  },
  "transcendence": {
    "content": {
      "title": "트랜센던스",
      "date": "42서울 2023년 12월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "디자인, 프론트엔드, 프로젝트 리드",
      "teamTitle": "팀",
      "team": ["박태양 백엔드", "안현준 벡엔드", "임윤선 게임"],
      "timelineTitle": "타임라인",
      "timeline": "4 Months, starts December 2023",
      "techTitle": "사용 기술",
      "techKeywords": "Vanilla JavaScript, Figma, HTML, CSS, Tailwindcss, Docker, Git/GitHub",
      "overviewTitle": "개요",
      "overview": [
        "트랜센던스는 Pong game 웹 사이트 프로젝트입니다. 디자인 단계부터 Figma를 활용해 컴포넌트화된 구조를 기획했으며, Tailwind CSS를 사용해 일관된 스타일을 적용했습니다.",
        "프론트엔드는 바닐라 JavaScript를 사용하여 구축되었습니다. 모듈화된 컴포넌트를 통해 코드 재사용성을 고려하였고 유지보수성과 확장성을 높였습니다.",
        "페이지 새로고침이 없는 원활한 사용자 경험을 위해 커스텀 라우터를 구현한 SPA 아키텍처를 적용했습니다.",
        "Redux 또는 Vuex와 유사한 Store 패턴을 사용하여 커스텀 상태 관리 시스템을 구현했습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "트랜센던스는 클래식 Pong game을 재해석한 웹사이트 프로젝트입니다."
    },
    "design": {
      "title": "DESIGN",
      "subTitle": "디자인을 어떻게 해야할까?",
      "first": "디자인 컴포넌트화",
      "firstContent": [
        "처음에는 컴포넌트와 개발은 생각하지 않고 막 디자인하기 시작했습니다. 하지만 이렇게 하다가는 개발을 할 때 고생을 하지 않을까. 다시 사용할 수 있는 디자인은 재사용하는게 좋지 않을까라는 생각에 3일에 걸쳐 리디자인을 시작했습니다.",
        "재사용성을 생각해 컴포넌트를 만들었고, 만든 컴포넌트를 활용해 페이지를 디자인했습니다. 그 결과 개발을 할때, 코드를 작성할 때 어떤 컴포넌트를 만들어야 할지 배치를 어디에 해야할지 생각하는 불필요한 시간들을 단축할 수 있었습니다."
      ]
    },
    "component": {
      "title": "COMPONENT",
      "subTitle": "SPA 구현을 위해 뭘 해야 할까?",
      "first": "코드 컴포넌트 모듈화",
      "firstContent": [
        "React 컴포넌트를 참고 했습니다. 컴포넌트화를 하기 위해서 컴포넌트 클래스를 만들었고, 모든 함수형 클래스들은 컴포넌트를 상속하여 render()를 통해 컴포넌트를 렌더링하게 됩니다."
      ],
      "firstCodeEx": ["Component 클래스는 render() 메소드를 가지고 있습니다."],
      "secondCodeEx": [
        "모든 함수형 클래스들은 Component 클래스를 상속하여 render()를 통해 렌더링하게 됩니다."
      ],
      "thirdCodeEx": ["createComponent 함수를 통해 컴포넌트를 생성합니다."],
      "fourthCodeEx": [
        "컴포넌트화를 통해 상황에 따라 페이지 전체를 리로드하는게 아니라 컴포넌트만 바꾸어 줄 수 있습니다."
      ]
    },
    "route": {
      "title": "ROUTER",
      "subTitle": "새로고침을 하지 않고 페이지 전환을 어떻게 할까?",
      "first": "커스텀 라우터 구현",
      "firstContent": [
        "Router 클래스를 통해 URL에 맞는 page를 반환합니다. JavaScript의 History API와 관련된 기능들을 사용하여 URL을 감지하고 기록을 관리하고 root id를 찾아 페이지 컴포넌트를 반환합니다."
      ],
      "firstCodeEx": [
        "App 클래스는 애플리케이션의 시작점으로 Router라는 객체를 만들어서 URL과 해당 페이지가 매칭되는 규칙을 정해줍니다."
      ],
      "secondCodeEx": [
        "Router 클래스가 생성되면, init이라는 함수가 호출되고, 처음 접속했을 때 현재 URL을 읽어서 그에 맞는 페이지를 찾아 보여줍니다. (routing 함수 호출)",
        "앞으로 사용자가 다른 페이지로 이동할 때(예: 다른 링크를 클릭할 때) 그 URL을 처리합니다."
      ],
      "thirdCodeEx": [
        "사용자가 페이지 내에서 링크를 클릭하면, 기본적인 링크의 동작(브라우저가 새로고침 되며 페이지를 불러오는 것)을 막고(e.preventDefault()), routePush라는 함수가 호출됩니다.",
        "routePush는 브라우저의 URL을 바꾸고 (window.history.pushState), URL이 바뀌었으니 새로운 페이지를 화면에 보여주기 위해 routing이라는 함수를 호출합니다.",
        "routing 함수는 현재의 URL(예: /home/, /profile/)에 맞는 페이지 컴포넌트를 찾아서 화면에 그립니다."
      ],
      "fourthCodeEx": [
        "routing 함수에서 페이지 컴포넌트를 찾아내면, 그 컴포넌트를 render 함수를 통해 화면에 그립니다.",
        "render 함수는 특정한 HTML 요소(이 경우 rootElement)를 찾아서 그 안에 새로 생성한 페이지를 넣습니다."
      ]
    },
    "pubsub": {
      "title": "PUB/SUB",
      "subTitle": "다크모드, 프로필 상태, 게임모드 상태는 어떻게 관리해야 할까?",
      "first": "Pub/Sub 패턴",
      "firstContent": [
        "Redux의 store를 참조해, 한 곳에서 상태가 변경되면 그 변경을 구독하고 있던 다른 부분에서 변화를 감지해 반응하는 패턴인 Publisher/Subscriber 패턴을 사용했습니다."
      ],
      "firstCodeEx": [
        "PubSub 클래스는 이벤트를 발행하고 구독하는 메커니즘을 구현합니다."
      ],
      "secondCodeEx": [
        "Store 클래스는 전역 상태를 관리하고, 상태가 변경될 때 이벤트를 발생시킵니다. 여기서 핵심은 상태를 Proxy로 감싸서, 상태가 변경될 때 이벤트를 자동으로 발행하도록 만든 것입니다."
      ],
      "thirdCodeEx": [
        "상태를 변경하려면 actions와 mutations를 사용하며, 직접 상태를 수정하는 대신 mutations를 통해 상태를 안전하게 변경합니다.",
        "예를 들어 toggleDarkMode는 다크 모드를 켜고 끄는 기능을 합니다. 상태가 변경되면 Proxy가 set을 감지하고, 상태 변경 이벤트를 발행합니다."
      ],
      "fourthCodeEx": [
        "상태가 변경되면 자동으로 이벤트가 발행되고, 해당 이벤트를 구독한 컴포넌트는 그 변화를 감지하여 UI를 업데이트하거나 다른 동작을 수행합니다."
      ]
    },
    "collaboration": {
      "title": "COLLABORATION",
      "subTitle": "협업을 위한 노력",
      "first": "GitHub flow",
      "firstContent": [
        "GitHub flow 브랜치 전략을 기반으로 한 Git 협업 시나리오를 통해 체계적인 개발을 제안, 브랜치를 관리했습니다.",
        "GitHub Issue 라벨, Issue Template, PR Template, Git Commit Convention 규칙들을 생성 하여 협업을 진행했습니다."
      ],
      "gitflow": [
        "작업 이슈 등록",
        "브랜치 생성",
        "작업",
        "PR 생성",
        "리뷰",
        "테스트",
        "병합"
      ],
      "second": "노션",
      "secondContent": [
        "노션을 사용해 팀원들과의 정보격차를 해소 할 수 있도록 노력했습니다."
      ]
    }
  },
  "mysite": {
    "content": {
      "title": "마이사이트",
      "date": "2024년 9월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "내가 혼자 다함.",
      "teamTitle": "팀",
      "team": ["이의찬"],
      "timelineTitle": "타임라인",
      "timeline": "1주일, 2024년 9월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "Next.js, TypeScript, Figma, Tailwindcss, Redux, middleware, i18n, Framer",
      "overviewTitle": "개요",
      "overview": [
        "마이사이트는 포트폴리오 웹사이트입니다. Next.js를 통해서 구현하였고, 모든 디자인을 Tailwindcss로 구현하였고 반응형을 고려하여 디자인되었습니다. 컴포넌트 움직임들을 Framer Motion을 사용해서 구현하였습니다.",
        "Redux를 활용해 다크모드 상태를 전역으로 관리합니다. middleware를 통한 동적 라우팅과 함께 i18n 라이브러리를 활용해 한영 전환 기능을 구현하였습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "개인 포트폴리오 웹사이트로 프로젝트의 설명과 개인 이력서를 제공합니다."
    },
    "design": {
      "title": "DESIGN",
      "subTitle": "디자인할 때 고려한 요소들.",
      "first": "컴포넌트화",
      "firstContent": [
        "디자인을 시작할 때부터, 재사용성을 고려하여 컴포넌트화를 적용하였습니다. 컴포넌트화를 통해 개발과정에서 최적화를 추구하였습니다."
      ],
      "second": "반응형 디자인",
      "secondContent": [
        "화면 크기에 따라 변하는 디자인을 적용하였습니다. 코드에서는 Tailwindcss을 사용하여 디자인을 적용하였습니다.",
        "디자인에 따라서 애니메이션이 바뀌는 부분은 window.addEventListener를 통해 감지해주었습니다."
      ],
      "firstCodeEx": [
        "컴포넌트 같은 경우는 마우스를 올리면 설명이 표시됩니다. 하지만 핸드폰에서는 마우스를 올릴 수가 없기 때문에 다른 애니메이션을 적용해주기 위해. 사이즈를 체크해주었습니다."
      ],
      "secondCodeEx": [
        "화면이 클때는 마우스를 올려야 표시가 되지만, 핸드폰 사이즈일때는 그냥 화면에 들어오는 컴포넌트에 설명이 표시됩니다."
      ]
    },
    "lang": {
      "title": "LANGUAGE",
      "subTitle": "한영 전환은 어떻게 해야할까?",
      "first": "middleware",
      "firstContent": [
        "동적라우팅을 사용하여 locale에 따라 ko, en을 감지합니다. langmodeswitch가 눌리면 새로운 경로로 설정하고, middleware는 그 신호를 가로채 알맞는 경로로 바꾸어줍니다."
      ],
      "second": "i18n",
      "secondContent": [
        "언어 변환 등 국제화처리를 가능하게 해주는 i18n 라이브러리를 사용하였습니다. locale 설정에 따라 다른 message 파일을 불러옵니다."
      ],
      "firstCodeEx": [
        "middleware를 통해 locale의 값을 감지합니다."
      ],
      "secondCodeEx": [
        "라이브러리에서 Locale의 값에 따라 내보내주어야 할 파일의 값을 설정해줍니다."
      ],
      "thirdCodeEx": [
        "provider를 사용해서 locale 값을 감지합니다."
      ],
      "fourthCodeEx": [
        "useTranslations를 사용해서 locale에 맞는 파일을 가져와 텍스트를 표시합니다."
      ]
    },
    "table": {
      "title": "TABLECONTENTS",
      "subTitle": "수많은 페이지에서 목차를 찾아가는 방법.",
      "first": "Section",
      "firstContent": [
        "IntersectionObserver를 사용해 각 section을 감지하였습니다. 클릭하면 scrollIntoView를 사용해 각 section으로 이동합니다."
      ],
      "firstCodeEx": [
        "각 section의 위치를 확인하고, 현재 화면에 보이는 section이 무엇인지 확인합니다."
      ],
      "secondCodeEx": [
        "목차를 클릭하면 각 section으로 넘어갑니다."
      ]
    },
    "state": {
      "title": "STATE",
      "subTitle": "페이지에서 Redux를 사용해 상태관리를 하는 방법.",
      "first": "다크모드",
      "firstContent": [
        "darkModeSwitch를 누르면 dispatch를 사용해 redux에 값을 저장합니다. provider를 통해 locale의 값을 확인하고, dark 모드 값을 변경합니다."
      ],
      "firstCodeEx": [
        "다크모드 버튼을 누르면 dispatch를 통해 값을 업데이트합니다."
      ]
    },
    "animation": {
      "title": "ANIMATION",
      "subTitle": "부드러운 사용자 경험성 증가.",
      "first": "Framer",
      "firstContent": [
        "마우스를 올리면 컴포넌트가 살짝 올라오는 것, Nav 바 이동 popop 컴포넌트 표시 등을 Framer를 사용해 움직임을 부드럽게 구현했습니다."
      ],
      "firstCodeEx": [
        "컴포넌트가 나타나고 사라지는 애니메이션을 적용하였습니다."
      ]
    }
  },
  "bookmoeum": {
    "content": {
      "title": "책모음",
      "date": "2024년 8월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "내가 혼자 다함.",
      "teamTitle": "팀",
      "team": ["이의찬"],
      "timelineTitle": "타임라인",
      "timeline": "3주, 2024년 8월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "Next.js, TypeScript, Figma, Tailwindcss, Redux, React-query, OPEN APIs, Firebase, middleware, useInfinityScroll, Framer, Phase",
      "overviewTitle": "개요",
      "overview": [
        "책모음 서비스는 여러 사이트를 돌아다니면서 책을 찾을 필요없이, 한 곳에서 책을 어디서 볼 수 있는지 찾아볼 수 있는 책 검색 사이트입니다.",
        "피그마를 활용하여 타이포그래피, 색상, 간격 UI 컴포넌트 등 디자인 시스템을 구현 한뒤에 디자인 작업을 진행했습니다. 반응형을 고려하여 디자인 되었습니다.",
        "Next.js를 기반으로 작성된 웹페이지이며 TypeScript를 사용해 타입을 명시하였습니다. 책 정보는 검색에서는 최대한 많은 책 정보를 제공하는 Naver API를 사용했고, 책 디테일 페이지에 들어갔을 때는 더 디테일한 정보를 제공하는 알라딘 API를 활용하였습니다.",
        "로그인과 DB는 Firebase를 사용하여 구현하였고, 책 정보는 교보문고, Yes24, 알라딘, 리디북스 내가 선택한 도서관에서 책보유 유무를 검사해 표시합니다. 알라딘과 도서관은 API를 사용하였고, 나머지 서점들을 크롤링을 통해 값들을 가져왔습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "서점과 도서관의 OPEN APIs와 크롤링을 사용하여 어디서 책을 읽을 수 있는지 한곳에서 정보를 제공합니다."
    },
    "design": {
      "title": "DESIGN SYSTEM",
      "subTitle": "디자인은 어떻게 만들어야 할까?",
      "first": "디자인 시스템 구축",
      "firstContent": [
        "일관화된 디자인을 적용하여 개발을 할 때 헷갈리거나 규격이 맞지 않는 일이 발생하지 않도록 하기 위해 디자인 시스템을 도입했습니다.",
        "Foundation에는 색상과 타이포그래피 및 규격을 설정해 저장해두었고, UI 컴포넌트에서 설정을 가져와 사용하였습니다.",
        "디자인 단계에서부터 컴포넌트화를 생각해 디자인하였고, 컴포넌트들을 UI 별로 나눠 디자인을 한 다음 최종 디자인에서 사용하였습니다."
      ]
    },
    "api": {
      "title": "OPEN API",
      "subTitle": "어떤 API를 어떻게 사용해야할까?",
      "first": "서점 API",
      "firstContent": [
        "국내도서정보를 제공하는 서점 API는 네이버, 알라딘이 존재하는데, 각각의 API마다 특색이 다릅니다.",
        "그래서 검색을 할 때는 책 정보가 더 많은 네이버를 사용하였고, 책 디테일 페이지에서는 각 도서마다 더 자세한 정보를 제공하는 알라딘 API를 사용하였습니다."
      ],
      "second": "도서관 API",
      "secondContent": [
        "도서관 같은 경우는 공공 API를 사용해 API 제공을 하는 도서관을 사용하였고, 도서관리스트를 따로 저장해 놓고 원하는 도서관을 선택하면 각 도서관 id를 가지고 도서의 보유 유무를 확인하였습니다."
      ],
      "third": "React-query 및 api 폴더",
      "thirdContent": [
        "api로 가져온 값은 staletime으로 api를 불필요하게 많이 재호출할 필요없게 캐싱을 합니다.",
        "api는 client-side에서 fetch를 통해 바로 api를 가져오는 것이 아니라. 각 api마다 폴더를 나눠놓고 동일한 형식으로 server component에서 api를 호출할 수 있도록 했습니다."
      ],
      "firstCodeEx": [
        "검색 결과는 네이버 API를 사용합니다."
      ],
      "secondCodeEx": [
        "결과값 리스트는 useInfiniteQuery를 사용해 스크롤을 내리면 자동으로 다음 페이지를 불러올 수 있게 구현해주었습니다."
      ],
      "thirdCodeEx": [
        "책 정보는 각각 서점에 따른 크롤링과 API를 통해 가져오게 됩니다."
      ]
    },
    "state": {
      "title": "STATE",
      "subTitle": "페이지가 넘어갈 때 정보를 어떻게 넘겨줄 수 있을까?",
      "first": "API 재호출 문제",
      "firstContent": [
        "책검색 페이지와 책 디테일 페이지는 라우터가 달라서 페이지를 다시 불러와야 합니다. 하지만 그때마다 api를 다시 불러와야 하는 지연문제가 발생합니다.",
        "그래서 생각을 한 방법이 책 검색에서 이미 한번 불러온 결과값을 책 디테일 페이지에 넘겨주어 값이 바로 표시되게 하는 것이었습니다."
      ],
      "second": "Redux 사용",
      "secondContent": [
        "query를 통해서 검색 페이지에서 디테일 페이지에 값을 전달하는 방법도 있었지만, 그렇게 하면 url가 너무 더러워지기 때문에 Redux에 저장해놓고 그 값을 가져오는 방법을 선택했습니다."
      ],
      "firstCodeEx": [
        "책 정보를 리스트화 할 당시 각 책마다 클릭을 하면 Redux를 통해 값을 관리합니다."
      ],
      "secondCodeEx": [
        "BookDetail 페이지에서는 api를 다시 불러와 책 정보를 가져오는 것이 아니라. Redux에서 관리되고 있는 정보를 가져와 페이지를 구성하게 됩니다."
      ]
    },
    "login": {
      "title": "LOGIN",
      "subTitle": "사용자에 따라서 로그인 유저를 검사하는 방법",
      "first": "Firebase",
      "firstContent": [
        "로그인 같은 경우는 firebase를 사용해서 이메일과 비밀번호를 사용하여 로그인하는 방법, 구글을 통해서 로그인하는 방법을 구현하였습니다."
      ],
      "second": "Middleware",
      "secondContent": [
        "사용자에 따라서 본인의 데이터베이스가 존재하고 내 서재를 확인해야 하기 때문에 로그인 한 상태인지 아닌지를 확인해야합니다.",
        "확인은 middleware를 통해서 신호를 가로챈다음 지정한 링크인지 아닌지를 확인하고 그에 맞는 페이지를 보여줍니다."
      ],
      "firstCodeEx": [
        "middleware는 페이지 루트에 위치하며 요청을 중간에서 가로채 지정된 경로를 확인합니다.",
        "경로를 확인했을 때 로그인을 해야 하는 상황이라면 로그인 페이지로 리다이렉션을 시켜줍니다."
      ]
    },
    "data": {
      "title": "DB",
      "subTitle": "저장해야 하는 정보는 어떻게 관리하는가?",
      "first": "Firestore",
      "firstContent": [
        "처음에는 유저 data에 각 사용자가 저장한 책 리스트를 isbn으로만 저장을 했으나, 그렇게 되면 책 리스트에서도 api를 불러와야 하기 때문에, 이미 한번 불러온 api를 저장할 당시 페이지에서 data에 넣어줬습니다."
      ],
      "firstCodeEx": [
        "사용자가 선택한 책은 순서별로 관리가 되어야하기 때문에 저장을 한 시간도 같이 집어넣어주었습니다."
      ]
    },
    "animation": {
      "title": "ANIMATION",
      "subTitle": "조금 더 사용자 친화적인 UI/UX 고려.",
      "first": "Phase",
      "firstContent": [
        "api로 값을 가져올 때 단순히 로딩 중이라고만 뜨면 심심할 것 같아. Figma로 캐릭터 작업 후 Phase라는 애니메이션 툴을 사용하여 mp4로 만들어 준다음에 loading시 표시되게 했습니다."
      ],
      "second": "CSS && Framer",
      "secondContent": [
        "홈페이지에서 책리스트가 표시되는 부분과 서점 리스트가 표시되는 부분은 각각 CSS와 Framer를 사용해 구현하였습니다."
      ]
    },
    "responsive": {
      "title": "RESPONSIVE DESIGN",
      "subTitle": "사용자는 어떤 기기를 더 많이 사용할까?",
      "first": "반응형 디자인",
      "firstContent": [
        "저 같은 경우는 노트북을 더 많이 사용하지만 주변에 책 읽기 좋아하는 사람들에게 설문조사를 한 결과 핸드폰을 사용하는 빈도가 높아. 디자인과 개발시 반응형 디자인을 고려하여 디자인하였습니다.",
        "크기에 따라 footer가 없어지거나 header가 내려오는 등의 디자인의 변화를 통해 각 기기마다 사용자 경험을 고려하였습니다."
      ]
    }
  }
}
