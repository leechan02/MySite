{
  "title": "이의찬",
  "description": "이의찬의 개인 웹사이트에 오신 것을 환영합니다!",
  "header": {
    "home": "홈",
    "projects": "프로젝트",
    "info": "정보"
  },
  "resume" : {
    "resume": "/resume/Resume(ko).pdf"
  },
  "work": {
    "mainTitle": "만드는 걸 좋아합니다.",
    "subTitle": "한국 사는 백수.",
    "bookmoeum": {
      "title": "책모음",
      "date": "서울 2024년 8월",
      "description": "책 검색 웹서비스."
    },
    "mysite": {
      "title": "마이사이트",
      "date": "서울 2024년 9월",
      "description": "포트폴리오 웹사이트."
    },
    "webserv": {
      "title": "웹서브",
      "date": "42서울 2023년 7월-2023년 11월",
      "description": "c++98로 만든 웹서버."
    },
    "transcendence": {
      "title": "트랜센던스",
      "date": "42서울 2023년 12월-2024년 3월",
      "description": "SPA 핑퐁게임 웹사이트."
    }
  },
  "info": {
    "mainTitle": "안녕하세유, 이의찬입니다.",
    "subTitle": "문제를 정의하고 해결해 세상을 조금 더 편리하게 만드는 것을 좋아합니다.",
    "about": {
      "leftFirstTitle": "컴퓨터공학을 선택한 배경",
      "leftFirstContent": [
        "처음부터 개발에 관심이 있던 건 아니었습니다. 2년 전만 해도 코딩의 코자도 모르던 학생이었지만, 세상에 관심이 많아지기 시작하면서 불편한 점들이 많이 존재한다는 사실을 발견하게 됩니다.",
        "그 과정에서 문제 정의 능력의 중요성을 알게 되었고, 그 문제를 해결하기 위한 기술에 관심을 갖게 됩니다.",
        "그 결과 단순히 강의 위주로만 학습하는 것이 아닌 프로젝트 위주의 능동적인 학습을 통해 운영체제, 자료구조, 알고리즘, 네트워크 등등 컴퓨터공학의 기본 개념들을 배울 수 있는 42서울이라는 학교를 발견하였고, 2년간의 학습을 마치고 현재는 프론트엔드라는 분야에 관심을 갖고 개발자를 지망하고 있습니다."
      ],
      "leftSecondTitle": "코딩 스타일",
      "leftSecondContent": [
        "아름다운 것을 좋아합니다. 그렇기 때문에 코드를 작성할 때 처음 보는 사람도 이해할 수 있는지, 구조가 복잡하지는 않은지 고민합니다. 최적화는 또 다른 문제라고도 할 수 있겠지만 복잡한 코드가 더 성능이 좋은 코드라고 생각하지는 않습니다.",
        "혼자보다는 여러명이 더 낫다고 생각하기 때문에 개발자에게 커뮤니케이션 능력은 필수라고 생각합니다. 노베이스에서 시작했기 때문에 누구나 알아듣기 쉽도록 설명하는 것을 좋아하고 잘합니다."
      ],
      "rightFirstTitle": "궁금한 것이 많습니다",
      "rightFirstContent": [
        "저는 궁금한 게 많고, 배우고 싶은 것도 많습니다. 살아가다 보면 아는 것보다 모르는 것투성이라는 사실만 알게 됩니다. 하지만 이 때문에 저는 항상 틀릴 수 있음을 인지하고 언제나 더 성장하려고 노력합니다.",
        "세상에 어려운 것은 있지만 불가능한 것은 없다고 생각합니다. 2년 전 완전 새로운 분야에 도전했기 때문에, 남들보다 더 열심히 할 수밖에 없었습니다. ",
        "문제가 생길 때마다 어떻게든 해결해 나갔고, 300번이 넘는 코드 리뷰와 한 프로젝트에서 10,000줄이 넘는 코드를 작성하는 등의 경험을 쌓아나갔습니다.",
        "그 결과 새로운 지식과 기술을 습득하고 문제를 마주하는 데에 두려움이 없어졌습니다."
      ],
      "rightSecondTitle": "여가 시간에는,",
      "rightSecondContent": [
        "아는 만큼 보게 되고, 보는 만큼 꿈꿀 수 있다고 생각합니다. 그렇기 때문에 배우는 것, 도전하는 것, 기록하는 것을 좋아합니다.",
        "알고, 보고 싶기 때문에 책을 읽습니다. 도전하는 것을 좋아해서 일단 해봅니다. 최근에는 히말라야에 올라갔다 왔습니다.",
        "배운 것은 기록하고 말해야 본인 것이 된다고 생각합니다. 끄적이는 성장 일기 같이 유튜브도 조그맣게 운영하고 있습니다."
      ]
    },
    "education": {
      "first": "42서울",
      "firstLocation": "한국, 서울",
      "firstDate": "2022년 7월 - 2024년 7월",
      "firstContent": "다양한 토이 프로젝트를 통한 컴퓨터공학 지식 학습",
      "second": "한국방송통신대학교",
      "secondLocation": "한국, 서울",
      "secondDate": "2023년 9월 - 현재",
      "secondContent": "2028년 졸업 예정, 컴퓨터공학 학사"
    },
    "etc": {
      "first": "오픽 AL",
      "second": "정보처리기능사"
    },
    "skills": {
      "title": "SKILLS",
      "language": {
        "title": "언어",
        "skills": "C/C++, JavaScript, TypeScript, HTML, CSS, English",
        "details": [
          { "skill": "C/C++ ⭐️⭐️", "description": "멀티 프로세스, 멀티 스레드, 객체지향 프로그래밍, 메모리 관리를 생각한 여러 토이 프로젝트 구현 경험." },
          { "skill": "JavaScript ️⭐⭐️️", "description": "Vanilla JavaScript만으로 SPA 구현 경험." },
          { "skill": "TypeScript ⭐️", "description": "React 사용하면서 interface를 활용한 타입 설정." },
          { "skill": "HTML ⭐⭐️️", "description": "html로 페이지 만들기 가능." },
          { "skill": "CSS ⭐⭐️️", "description": "CSS로 디자인 가능." },
          { "skill": "English ⭐️⭐️⭐️", "description": "오픽 AL, 원어민과 무리없이 의사소통 가능. 영어문서 읽는데에 문제 없음." }
        ]
      },
      "frontend": {
        "title": "프론트엔드",
        "skills": "React, Next.js, React Query, Redux, TailwindCSS, Framer Motion, i18n",
        "details": [
          { "skill": "React ⭐️⭐️", "description": "React-dom을 사용한 route 및 컴포넌트 개발 가능." },
          { "skill": "Next.js ⭐️⭐️", "description": "동적라우팅 및 middleware를 사용한 라우팅 개발 경험." },
          { "skill": "React Query ⭐️", "description": "query 사용한 api 캐시 관리 및 무한 스크롤 구현 경험." },
          { "skill": "Redux ⭐️", "description": "다크모드 및 책정보 전역상태로 관리 경험." },
          { "skill": "TailwindCSS ⭐️⭐️", "description": "웬만한 디자인은 tailwindcss로 구현 가능. 개발 디자인 커스텀 가능." },
          { "skill": "Framer Motion ⭐️", "description": "간단한 애니메이션 효과 구현 가능." },
          { "skill": "i18n ⭐️⭐️", "description": "i18n 라이브러리를 활용한 한영전환 기능 구현 경험." }
        ]
      },
      "tools": {
        "title": "기타",
        "skills": "Git/GitHub, Figma, Slack, Notion, Visual Studio Code, Docker",
        "details": [
          { "skill": "Git/GitHub ⭐️⭐", "description": "Git Issue 관리 및 브랜치 전략 적용, 팀 협업 가능." },
          { "skill": "Figma ⭐️⭐️⭐️", "description": "디자인 시스템 구축 및 프로토타입 제작 가능." },
          { "skill": "Slack ⭐️⭐️⭐️", "description": "상시대기 팀원과 원활한 소통가능." },
          { "skill": "Notion ⭐️⭐️⭐️", "description": "웬만한 정보는 노션으로 정리, 팀스페이스 노션 정리 담당." },
          { "skill": "Visual Studio Code ⭐️⭐️️", "description": "비쥬얼스튜디오에서 vim 플러그인 사용하는 혼종유저." },
          { "skill": "Docker ⭐️", "description": "도커 이미지 빌드 및 세팅 가능." }
        ]
      }
    }
  },
  "webserv": {
    "content": {
      "title": "웹서브",
      "date": "42서울 2023년 7월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "구조 설계, HTTP 파싱, 디버깅 로그 작성, 코드 리펙토링, 동작 확인 페이지 구현",
      "teamTitle": "팀",
      "team": ["허진호", "안현준", "임윤선"],
      "timelineTitle": "타임라인",
      "timeline": "4달, 2023년 7월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "C++98, Makefile, HTML, CSS, Object Oriented Programming, Non-block I/O, I/O Multiplexing (kqueue), HTTP/1.1",
      "overviewTitle": "개요",
      "overview": [
        "웹서브는 42서울 프로젝트 중 하나로 C++98로 구현된 HTTP/1.1 호환 웹 서버를 구현하는 프로젝트입니다. 이 프로젝트는 저수준 네트워크 프로그래밍에 대한 숙련도와 HTTP 프로토콜에 대한 이해, 그리고 논블로킹 I/O 작업과 효율적인 요청 처리의 구현을 요구합니다.",
        "주요 기능으로는 kqeue() (또는 이와 동등한 기능)를 사용한 I/O 멀티플렉싱이 있어, 서버가 절대 블로킹되거나 무한정 멈추지 않도록 보장합니다. 또한 GET, POST, DELETE 등 여러 HTTP 메서드를 지원하면서 정적 웹사이트를 제공 해야합니다.",
        "이러한 고급 개념들을 구현함으로써, 웹서브는 웹 서버 아키텍처를 이해하기 위한 실용적인 학습 도구로서의 역할뿐만 아니라, 고성능 네트워크 애플리케이션을 만드는 데 있어 개체지향 프로그래밍 언어인 C++의 강력함과 유연성을 보여줍니다."
      ]
    },
    "highlights": {
      "title": "하이라이트",
      "highlights": "C++98로 구현된 HTTP/1.1 호환 웹서버입니다."
    },
    "problem": {
      "title": "THE PROBLEM",
      "subTitle": "Nignx를 참고해서 만들면 되지 않을까?",
      "first": "Nignx 구조",
      "firstContent": [
        "처음에는 Nginx 구조를 참조해 마스터 프로세스가 워커 프로세스를 생성하고 워커 프로세스에서는 각 쓰레드에 따라서 신호를 등록하고 응답을 보내는 멀티 프로세스 멀티 스레드 구조를 생각하고 코드를 작성했습니다.",
        "하지만 구조를 거의 다 작성했을 때 쯤, 프로세스는 하나만 사용해야 한다는 사용자 요구 사항을 발견해 결국 설정파일 파싱만 Nginx를 참고해서 만드는 것에 만족해야 했습니다."
      ]
    },
    "architecture": {
      "title": "ARCHITECTURE",
      "subTitle": "웹서버의 구조는 어떻게 되어야 하는가?",
      "first": "하나의 프로세스",
      "firstContent": [
        "하나의 프로세스에서 kqueue를 통해 이벤트를 관리하고 핸들링합니다.",
        "설정파일을 토대로 포트를 확인하고 연결합니다. 이벤트는 kqueue에서 관리되고 상속된 클래스에 따라 Read, Write, CGI 등으로 나누어져서 처리가 됩니다.",
        "응답이 들어오면 HTTP 형식에 맞춰서 파싱이 되며 그에 맞는 요청을 처리하고 응답을 내보냅니다."
      ]
    },
    "config": {
      "title": "CONFIG",
      "subTitle": "Nignx와 유사한 설정 파일 파싱 구조",
      "first": "Config Tree",
      "firstContent": [
        "설정 파일은 {}, ;를 기준으로 블럭 형식으로 되어있고, 감싸고 있는 괄호를 부모라고 한다면 자식요소는 부모 요소의 설정을 반영합니다.",
        "그렇기 때문에 {}와 ;를 기준으로 트리를 구성한다면 location 블럭이 수 없이 들어가도 부모 요소의 모든 설정을 다 반영할 수 있습니다."
      ],
      "firstCodeEx": [
        "트리와 Map은 Common 클래스에서 전역으로 관리됩니다."
      ],
      "secondCodeEx": [
        "WebServer가 생성되면 생성됨과 동시에 생성자에서 config 파일을 넘겨줘서 파싱을 완료합니다."
      ],
      "thirdCodeEx": [
        "트리는 Node로 관리하고, http, server, location 블럭 레벨로 나누어져 관리됩니다. 각 노드는 각각 레벨에서 보유해야 할 토큰과 부모 요소 그리고 자식 노드들 가지고 있습니다."
      ],
      "second": "Config Map",
      "secondContent": [
        "토큰을 기준으로 트리가 생성되었다면, location을 기준으로 Map을 생성해줍니다. 트리에서 location이 어디에 위치해있는지 기억하기만 한다면 들어온 location을 찾으려고 트리를 다 검색할 필요없이 location 위치에서 부모요소를 타고 올라가면서 설정들을 확인만 하면 되기 때문입니다."
      ],
      "fourthCodeEx": [
        "port, server_name, location을 기준으로 Map을 생성합니다. MultiMap을 사용함으로서. 트리를 다 순회하면서 location 노드를 찾을 필요없기때문에 접근시간을 O(N)에서 O(logN)으로 줄였습니다.",
        "std::unordered_map(hashmap)을 사용하면 O(1)로 더 줄일 수 있었지만, c++98에서는 해당 STL을 제공하지 않아 사용할 수 없었습니다."
      ],
      "fifthCodeEx": [
        "Nginx에서는 PCRE 라이브러리를 지원해 검사하지만, 이 프로젝트에서는 '~' '*' '$' 문법만 지원하도록 구현되어있습니다."
      ],
      "sixthCodeEx": [
        "Map에서 location 블럭을 검색할 때 PCRE 검사를 부분적('~', '*', '$')으로 지원합니다."
      ],
      "seventhCodeEx": [
        "port와 host uri를 알기만하면 location node를 가져올 수 있고, 그 node를 기준으로 설정된 세팅값이 뭔지 FindValue를 통해 가져올 수 있습니다."
      ]
    },
    "http": {
      "title": "REQUEST&&RESPONSE",
      "subTitle": "서버에서 요청을 받고 응답을 하는 과정",
      "first": "요청 수신",
      "firstContent": [
        "서버는 recv() 함수를 통해 클라이언트로부터 데이터를 수신하고, 이 데이터를 각각의 Connection 객체가 소유한 Http 객체로 전달하여 HTTP 요청 파싱을 시작합니다."
      ],
      "second": "응답",
      "secondContent": [
        "파싱된 요청이 HTTP 요청인 경우, 서버는 Router를 통해 HTTP 메서드(GET, POST, DELETE)에 맞는 핸들러를 호출합니다.",
        "각 메서드는 HTTP/1.1 프로토콜을 준수하여 규칙에 맞는 적합한 비즈니스 로직을 처리한 후 적절한 Response 메시지를 생성하여 클라이언트에 응답합니다."
      ],
      "third": "CGI 요청 처리",
      "thirdContent": [
        "CGI 요청인 경우, 서버의 메인 프로세스는 fork() 시스템 호출을 통해 자식 프로세스를 생성하고, 자식 프로세스는 execve()를 통해 CGI 스크립트를 실행합니다.",
        "위와같은 방식은 CGI 요청이 메인 프로세스의 성능에 영향을 주지 않도록 설계된 비동기 처리 방식입니다."
      ]
    }
  },
  "transcendence": {
    "content": {
      "title": "트랜센던스",
      "date": "42서울 2023년 12월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "디자인 다함, 프론트엔드 다함, 프로젝트 리드",
      "teamTitle": "팀",
      "team": ["박태양", "안현준", "임윤선"],
      "timelineTitle": "타임라인",
      "timeline": "4 Months, starts December 2023",
      "techTitle": "사용 기술",
      "techKeywords": "Vanilla JavaScript, Figma, HTML, CSS, Tailwindcss, Docker, Git/GitHub",
      "overviewTitle": "개요",
      "overview": [
        "트랜센던스는 Pong game 웹 사이트 프로젝트입니다. 디자인 단계부터 Figma를 활용해 컴포넌트화된 구조를 기획했으며, Tailwind CSS를 사용해 일관된 스타일을 적용했습니다.",
        "프론트엔드는 바닐라 JavaScript를 사용하여 구축되었습니다. 모듈화된 컴포넌트를 통해 코드 재사용성을 고려하였고 유지보수성과 확장성을 높였습니다.",
        "페이지 새로고침이 없는 원활한 사용자 경험을 위해 커스텀 라우터를 구현한 SPA 아키텍처를 적용했습니다.",
        "Redux 또는 Vuex와 유사한 Store 패턴을 사용하여 커스텀 상태 관리 시스템을 구현했습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "트랜센던스는 클래식 Pong game을 재해석한 웹사이트 프로젝트입니다."
    },
    "design": {
      "title": "DESIGN",
      "subTitle": "디자인을 어떻게 해야할까?",
      "first": "디자인 컴포넌트화",
      "firstContent": [
        "처음에는 컴포넌트와 개발은 생각하지 않고 막 디자인하기 시작했습니다. 하지만 이렇게 하다가는 개발을 할 때 고생을 하지 않을까. 다시 사용할 수 있는 디자인은 재사용하는게 좋지 않을까라는 생각에 3일에 걸쳐 리디자인을 시작했습니다.",
        "재사용성을 생각해 컴포넌트를 만들었고, 만든 컴포넌트를 활용해 페이지를 디자인했습니다. 그 결과 개발을 할때, 코드를 작성할 때 어떤 컴포넌트를 만들어야 할지 배치를 어디에 해야할지 생각하는 불필요한 시간들을 단축할 수 있었습니다."
      ]
    },
    "component": {
      "title": "COMPONENT",
      "subTitle": "SPA 구현을 위해 뭘 해야 할까?",
      "first": "코드 컴포넌트 모듈화",
      "firstContent": [
        "React 컴포넌트를 참고 했습니다. 컴포넌트화를 하기 위해서 컴포넌트 클래스를 만들었고, 모든 함수형 클래스들은 컴포넌트를 상속하여 render()를 통해 컴포넌트를 렌더링하게 됩니다."
      ],
      "firstCodeEx": [
        "Component 클래스는 render() 메소드를 가지고 있습니다."
      ],
      "secondCodeEx": [
        "모든 함수형 클래스들은 Component 클래스를 상속하여 render()를 통해 렌더링하게 됩니다."
      ],
      "thirdCodeEx": [
        "createComponent 함수를 통해 컴포넌트를 생성합니다."
      ],
      "fourthCodeEx": [
        "컴포넌트화를 통해 상황에 따라 페이지 전체를 리로드하는게 아니라 컴포넌트만 바꾸어 줄 수 있습니다."
      ]
    },
    "route": {
      "title": "ROUTER",
      "subTitle": "새로고침을 하지 않고 페이지 전환을 어떻게 할까?",
      "first": "커스텀 라우터 구현",
      "firstContent": [
        "Router 클래스를 통해 URL에 맞는 page를 반환합니다. JavaScript의 History API와 관련된 기능들을 사용하여 URL을 감지하고 기록을 관리하고 root id를 찾아 페이지 컴포넌트를 반환합니다."
      ],
      "firstCodeEx": [
        "App 클래스는 애플리케이션의 시작점으로 Router라는 객체를 만들어서 URL과 해당 페이지가 매칭되는 규칙을 정해줍니다."
      ],
      "secondCodeEx": [
        "Router 클래스가 생성되면, init이라는 함수가 호출되고, 처음 접속했을 때 현재 URL을 읽어서 그에 맞는 페이지를 찾아 보여줍니다. (routing 함수 호출)",
        "앞으로 사용자가 다른 페이지로 이동할 때(예: 다른 링크를 클릭할 때) 그 URL을 처리합니다."
      ],
      "thirdCodeEx": [
        "사용자가 페이지 내에서 링크를 클릭하면, 기본적인 링크의 동작(브라우저가 새로고침 되며 페이지를 불러오는 것)을 막고(e.preventDefault()), routePush라는 함수가 호출됩니다.",
        "routePush는 브라우저의 URL을 바꾸고 (window.history.pushState), URL이 바뀌었으니 새로운 페이지를 화면에 보여주기 위해 routing이라는 함수를 호출합니다.",
        "routing 함수는 현재의 URL(예: /home/, /profile/)에 맞는 페이지 컴포넌트를 찾아서 화면에 그립니다."
      ],
      "fourthCodeEx": [
        "routing 함수에서 페이지 컴포넌트를 찾아내면, 그 컴포넌트를 render 함수를 통해 화면에 그립니다.",
        "render 함수는 특정한 HTML 요소(이 경우 rootElement)를 찾아서 그 안에 새로 생성한 페이지를 넣습니다."
      ]
    },
    "pubsub": {
      "title": "PUB/SUB",
      "subTitle": "다크모드, 프로필 상태, 게임모드 상태는 어떻게 관리해야 할까?",
      "first": "Pub/Sub 패턴",
      "firstContent": [
        "Redux의 store를 참조해, 한 곳에서 상태가 변경되면 그 변경을 구독하고 있던 다른 부분에서 변화를 감지해 반응하는 패턴인 Publisher/Subscriber 패턴을 사용했습니다."
      ],
      "firstCodeEx": [
        "PubSub 클래스는 이벤트를 발행하고 구독하는 메커니즘을 구현합니다."
      ],
      "secondCodeEx": [
        "Store 클래스는 전역 상태를 관리하고, 상태가 변경될 때 이벤트를 발생시킵니다. 여기서 핵심은 상태를 Proxy로 감싸서, 상태가 변경될 때 이벤트를 자동으로 발행하도록 만든 것입니다."
      ],
      "thirdCodeEx": [
        "상태를 변경하려면 actions와 mutations를 사용하며, 직접 상태를 수정하는 대신 mutations를 통해 상태를 안전하게 변경합니다.",
        "예를 들어 toggleDarkMode는 다크 모드를 켜고 끄는 기능을 합니다. 상태가 변경되면 Proxy가 set을 감지하고, 상태 변경 이벤트를 발행합니다."
      ],
      "fourthCodeEx": [
        "상태가 변경되면 자동으로 이벤트가 발행되고, 해당 이벤트를 구독한 컴포넌트는 그 변화를 감지하여 UI를 업데이트하거나 다른 동작을 수행합니다."
      ]
    },
    "collaboration": {
      "title": "COLLABORATION",
      "subTitle": "협업을 위한 노력",
      "first": "GitHub flow",
      "firstContent": [
        "GitHub flow 브랜치 전략을 기반으로 한 Git 협업 시나리오를 통해 체계적인 개발을 제안, 브랜치를 관리했습니다.",
        "GitHub Issue 라벨, Issue Template, PR Template, Git Commit Convention 규칙들을 생성 하여 협업을 진행했습니다."
      ],
      "gitflow": [
        "작업 이슈 등록",
        "브랜치 생성",
        "작업",
        "PR 생성",
        "리뷰",
        "테스트",
        "병합"
      ],
      "second": "노션",
      "secondContent": [
        "노션을 사용해 팀원들과의 정보격차를 해소 할 수 있도록 노력했습니다."
      ]
    }
  },
  "mysite": {
    "content": {
      "title": "마이사이트",
      "date": "2024년 9월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "내가 혼자 다함.",
      "teamTitle": "팀",
      "team": ["이의찬"],
      "timelineTitle": "타임라인",
      "timeline": "1주일, 2024년 9월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "Next.js, TypeScript, Figma, Tailwindcss, Redux, middleware, i18n, Framer",
      "overviewTitle": "개요",
      "overview": [
        "마이사이트는 포트폴리오 웹사이트입니다. Next.js를 통해서 구현하였고, 모든 디자인을 Tailwindcss로 구현하였고 반응형을 고려하여 디자인되었습니다. 컴포넌트 움직임들을 Framer Motion을 사용해서 구현하였습니다.",
        "Redux를 활용해 다크모드 상태를 전역으로 관리합니다. middleware를 통한 동적 라우팅과 함께 i18n 라이브러리를 활용해 한영 전환 기능을 구현하였습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "개인 포트폴리오 웹사이트로 프로젝트의 설명과 개인 이력서를 제공합니다."
    }
  },
  "bookmoeum": {
    "content": {
      "title": "책모음",
      "date": "2024년 8월"
    },
    "overview": {
      "myRoleTitle": "내 역할",
      "myRole": "내가 혼자 다함.",
      "teamTitle": "팀",
      "team": ["이의찬"],
      "timelineTitle": "타임라인",
      "timeline": "3주, 2024년 8월 시작",
      "techTitle": "사용 기술",
      "techKeywords": "Next.js, TypeScript, Figma, Tailwindcss, Redux, React-query, OPEN APIs, Firebase, middleware, useInfinityScroll, Framer",
      "overviewTitle": "개요",
      "overview": [
        "책모음 서비스는 여러 사이트를 돌아다니면서 책을 찾을 필요없이, 한 곳에서 책을 어디서 볼 수 있는지 찾아볼 수 있는 책 검색 사이트입니다.",
        "피그마를 활용하여 타이포그래피, 색상, 간격 UI 컴포넌트 등 디자인 시스템을 구현 한뒤에 디자인 작업을 진행했습니다. 반응형을 고려하여 디자인 되었습니다.",
        "Next.js를 기반으로 작성된 웹페이지이며 TypeScript를 사용해 타입을 명시하였습니다. 책 정보는 검색에서는 최대한 많은 책 정보를 제공하는 Naver API를 사용했고, 책 디테일 페이지에 들어갔을 때는 더 디테일한 정보를 제공하는 알라딘 API를 활용하였습니다.",
        "로그인은 Firebase를 사용하여 구현하였고, 책 정보는 교보문고, Yes24, 알라딘, 리디북스 내가 선택한 도서관에서 책보유 유무를 검사해 표시합니다. 알라딘과 도서관은 API를 사용하였고, 나머지 서점들을 크롤링을 통해 값들을 가져왔습니다."
      ]
    },
    "highlights": {
      "title": "HIGHLIGHTS",
      "highlights": "서점과 도서관의 OPEN APIs와 크롤링을 사용하여 어디서 책을 읽을 수 있는지 한곳에서 정보를 제공합니다."
    }
  }
}